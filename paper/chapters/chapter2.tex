%-*-coding: utf-8-*-

\chapter{Симуляция эволюции распределения}
\section{Примеры моделей и распределений}
\begin{figure}[ht]
  \begin{center}
    \subfigure[Композиция стандартных распределений для задания начального распределения]{%
        \putImgx{0.4\textwidth}{pic03-1}
        \label{simul:init}
    }
    \subfigure[Изменения распределения согласно модели случайного блуждания]{%
        \putImgx{0.4\textwidth}{pic03-4}
        \label{simul:after}
    }
  \end{center}
  \caption{Пример симуляции изменения распределения без маршрута}
\end{figure}

\FloatBarrier
\subsection{Разновидности начальных распределений}
Начальное распределение частиц фактически может быть представлено любой двумерной функцией,
интеграл которой по всей плоскости равен единице. Однако для большинства применений кажется
достаточным задание начального распределения как композиции стандартных двумерных распределений
(рис. \ref{simul:init}), таких как равномерное распределение в произвольной области или
 нормальное распределение задаваемое еллипсом, содержащим $3\sigma$ вероятности и тому подобное.
 Инструмент симуляции предоставляет удобный инструмент их задания.

На протяжении всей симуляции распределение хранится в текстуре (матрице), пиксель которой
имеет достаточно малый размер при рисовании в мире, чтобы достаточно точно различать положения
 различных частиц, при этом достаточно большой, чтобы текстура покрывающая всю вероятность
 влезла в память GPU и ее обработка занимала приемлимое время.
\FloatBarrier
\subsection{Разновидности моделей изменения распределения}
Изменения распределений происходят с фиксированным временем дискретизации $\Delta t$.
Для симуляции изменений в большинстве моделей используется свертка с ядром с периодом $\Delta t$.

Процесс свертки с ядром осуществляется следующим образом, пусть $D_t, D_{t+\Delta t}$ ---
последовательные распределения, а $K$ --- ядро размера $(2k+1) \times (2k+1)$
(Пусть обращение к несуществующим элементам возвращает 0):

\begin{equation}
  D_{t+\Delta t}[i][j] = \sum\limits_{di=-k}^k \sum\limits_{dj=-k}^k D_t[i+di][j+dj] \cdot K[di][dj]
\end{equation}

Размер матрицы свертки выбирается такого размера, чтобы дать возможность симулировать
передвижение в произвольном направлении с достаточной точностью. На данный момент выбрано
значение $k = 5$.

Время $\Delta t$ выбирается исходя из размера ядра и физического размера пикселя.
Если размер пикселя $h \times h$, максимальная скорость перемещения объекта $v_{max}$
тогда (\ref{eq:deltat}). 
\begin{equation}\label{eq:deltat}
  \Delta t = \frac {k \cdot h} {v_{max}}
\end{equation}

\begin{itemize}
\item{
\textbf{Модель случайных блужданий}

Простейший пример модели изменения распределения --- модель случайных блужданий
(рис. \ref{simul:after}). Ядро для модели случайных блужданий представляет собой матрицу со
значениями равными площади пересечения текущей ячейки с кругом вписанным в квадрат размера
$2kh \times 2kh$. Ячейки соответственно отнормированы для равенства суммы единице.

Посредством изменения ядра (замены круга на кольца), можно изменять интенсивность блужданий.
}
\item{
\textbf{Модель движения в одном направлении}

Пусть заданы последовательности $\alpha_i, p_i, 1 \le i \le n$ --- углов и вероятностей
движения в направлении каждого из них. Для симулирования заданной модели можно
использовать $n$ экземпляров ядер и текстур для симуляции движения распределений
соответственно в каждом из направлений. На выходе для получения итогового распределения
достаточно скомбинировать полученные результаты с соответствующими весами $p_i$.
}
\item{
\textbf{Модель притяжения(отталкивания) к заданным точкам}

Иногда уместной оказывается модель избегания некоторых точек (например точек вблизи
текущей позиции поискового средства, если объект является вражеским и не желает быть
обнаруженным) или напротив приближения к ним (например в случае если объект знает ближайшее
положение суши, он может стремитья двигаться в ее направлениии). Здесь 
удобно возпользоваться аналогией с электрическими зарядами, однако действие электрических
сил для создания ускорения не кажется естественным в данной задаче. Значение функции
аналогичной силе Кулона будет задавать направление и скорость (вместо ускорения) движения
 при нахождении в данной точке. Таким образом каждая из точек имеет свой заряд $q_i$,
 позицию $pos_i$, радиус действия $R_i$ и закон убывания влияния, для примера используем
 Кулоновские $r^{-2}$. Пусть максимальная скорость перемещения объекта $v_{max}$.
Таким образом вектор скорости объекта в точке $p$ равен (\ref{eq:vqulon}).
\begin{equation}
  \chi_i(p) = 
  \left\{
    \begin{array}{ll}
      1 & \mbox{если } {(p - pos_i)^2 \le R_i} \\
      0 & \mbox{иначе }
    \end{array}
  \right.
\end{equation}

\begin{equation}
  v' = \sum\limits_{i=1}^n\frac{\chi_i(p) \cdot q_i \cdot (pos_i-p)} {|pos_i-p|^3} 
\end{equation}

\begin{equation}\label{eq:vqulon}
  v = min(|v'|, v_{max}) \cdot \frac {v'} {|v'|}
\end{equation}

При реализации данной модели, во время свертки ядро в каждой конкретной ячейке будет различным.
Таким образом приходится работать с текстурой скоростей из глобальной памяти вместо ядра в константной
памяти как в модели со случайными блужданиями, что в несколько раз замедляет время симуляции.
}
\end{itemize}
\FloatBarrier

\section{Процесс симуляции изменения распределения
 и прохождения маршрута}
\FloatBarrier
\subsection{Симуляция изменения распределения}
\drawfigurex{keyframe.png}{Схема применения частичных ядер}{pic:keyframe}{\textwidth}

Симуляция изменения распределения производится путем применения свертки текущего
распределения с ядром с промежутком времени $\Delta t_{frame}$. Если
$\frac {1} {\Delta t} \ge 60 FPS$, где $\Delta t$ --- время с которым необходимо применять
заданное ядро, тогда $\Delta t_{frame} = \Delta t$. Иначе время применения ядра слишком велико
и не обеспечивает необходимой динамичности.

Для обеспечения актуальной информации в промежутках между ключевыми кадрами, идущими с 
интервалом $\Delta t$, необходимо добавить $m$ промежуточных, так чтобы
$t_{frame} = \frac {\Delta t} {m + 1} \ge 60 FPS$. Таким образом из оригинального ядра
 $K_1$ нам необходимо получить $m$ промежуточных с некоторой точностью приближающих реальность 
$K_{\frac {1} {m+1}}, K_{\frac {2} {m + 1}}, ... , K_{\frac {m} {m + 1}}$. Посредством применения
заданных ядер к последнему ключевому кадру, будут получены приближенные распределения в 
промежуточные моменты времени (рис. \ref{pic:keyframe}), однако полученные с помощью этих
 ядер текстуры не будут использованы для построения следующих, что избавляет симулятор 
от накопления погрешности от применения приближенных ядер.

Для получения ядра $K_{\frac {i} {m + 1}}$ необходимо элементы ядра $K_{1}$ домножить на
$\alpha = 1 + c_0 - c_0^{\frac {i} {m+1}}$, где $c_0 = K_{1}[k][k]$, после чего добавить 
остаток $1 - \alpha$ к стационарной ячейке ядра $K[k][k]$.
\FloatBarrier
\subsection{Симуляция сбора частиц средством поиска}
\FloatBarrier
\section{Корректировка области симуляции с течением времени}
\begin{figure}[ht]
  \begin{center}
    \subfigure[Область симуляции, рассчитанная на начальном распределении]{%
        \putImgx{0.4\textwidth}{pic07-1}
        \label{corr:1}
    }
    \subfigure[Выход распределения за границы области, без корректировки]{%
        \putImgx{0.4\textwidth}{pic07-2}
        \label{corr:2}
    }
    \subfigure[Приближение распределения к границе области симуляции]{%
        \putImgx{0.4\textwidth}{pic07-3}
        \label{corr:3}
    }
    \subfigure[Изменение центра области симуляции согласно новому положению распределения]{%
        \putImgx{0.4\textwidth}{pic07-4}
        \label{corr:4}
    }
    \subfigure[Расширение и измененеие центра области симуляции]{%
        \putImgx{0.4\textwidth}{pic07-5}
        \label{corr:5}
    }
  \end{center}
  \caption{Корректировка области симуляции}
\end{figure}

\FloatBarrier

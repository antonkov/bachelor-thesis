% -*-coding: utf-8-*-
\startprefacepage

Задача определения маршрута поиска объекта на первый взгляд очень похожа на задачу коммивояжера. Однако в реальности все подругому и проявляется несколько других особенностей задачи:
\begin{itemize}
\item{Зачастую все вершины посетить физически невозможно. Соответственно выделяются вершины в которых более вероятно обнаружить объект. Сопоставим вершине $v$ величину $p_v$ --- вероятность обнаружить объект в этой вершине. $p_{path}=\sum\limits_{v\in path}p_v$. }
\end{itemize}

 Существующие подходы строят весь маршрут исходя из статичных данных в начальный момент времени --- информации о начальном распределении и модели его распределения. Таким образом главным недостатком существующих подходов является необходимость разработки нового алгоритма для всех различных моделей распределения. Учитывая тот факт, что подобрать правильную модель, хорошо приближающую реальность, крайне непросто, возникает необходимость разработки алгоритма, работающего единообразно на широком классе различных моделей. Основная идея рассматриваемого подхода --- использование симулятора для получения информации о распределении в любой момент времени при построении маршрута. Таким образом при планирование пользователь в первую очереь выберет модель, как можно лучше приближающую реальность в данном случае, а после запустит единственный алгоритм.

Концепт данной задачи был продемонстрирован на одной из выставок. К задаче был проявлен интерес и было решено внедрить ее в комплекс расчетных морских задач.

В главе 1 решаемая задача будет рассмотрена более подробно. Описаны классы маршрутов, получаемые при использовании стратегии ``Параллельное галсирование''. ПБудут приведены особенности задачи, которые отличают ее от классической задачи коммивояжера и делают невозможным использование ранее разработанных методов решения TSP для решения исходной задачи в общем случае.

В главе 2 будут рассмотрены вопросы, связанные с разработкой симулятора на CUDA. Обозначены предоставляемые им сервисы.

В главе 3 будет описан алгоритм построения маршрутов согласно стратегии ``Параллельное галсирование''.

\begin{comment}
Задача определения кратчайшего расстояния до конфигурации отрезков
(dist2segments), являясь частным случаем задачи dist2sites -- задачи о
минимальном расстоянии до произвольного набора линейных данных,
является одной из базовых задач вычислительной геометрии (computational
geometry) \cite{PrSh}. На решении данной задачи базируются решения некоторых задач
об избежании столкновений (collision avoidance problem) \cite{MarNav}, некоторых задач
из области геоинформационных систем (Geographic information system, GIS) \cite{CGinGIS},
текстурирования рельефа, математического моделирования движения твердых
тел в жидкости и многих других.

Задача определения кратчайшего расстояния до конфигурации
отрезков имеет очевидное решение -- это полный
перебор с отсечением, имеющий линейную сложность ($O(n)$) \cite{DnCG}. Однако, если
множество точек-запросов $Q$ имеет достаточно большую мощность, обычно
рассматривают так называемую диаграмму Вороного для отрезков (segment
Voronoi diagram, SVD) \cite{PrSh, CGAL}. Эта структура данных похожа на диаграмму
Вороного для точек (point Voronoi diagram) \cite{PrSh, CGAL}, однако она не может быть
представлена реберным списком с двойными связями (double-connected edge
list, DCEL, РСДС) \cite{PrSh, CGAL} в силу своей нелинейности. Хотя, конечно, можно
создать приближенный РСДС, сколь угодно точно описывающий диаграмму
Вороного для отрезков.

Очень часто возникает необходимость в достаточно
больших количествах запросов на поиск ближайших отрезков.
Например, такая необходимость возникает при расчете физики движения судов в морских
тренажерах \cite{MarNav}. Судов может быть достаточно много, объектов, с которыми
необходимо рассчитать взаимодействие, тоже достаточно много. Это означает,
что запросы расстояний до ближайших отрезков идут достаточно часто, чтобы это стало проблемой
для ЭВМ, вычислительная мощность которых может быть недостаточно
большой для такого потока данных. Такого рода запросы называются
массовыми запросами, а такая задача -- массовой задачей.

Массовая задача в \cite{PrSh} определена следующим образом. Существует
фиксированный набор входных данных $S$. Требуется вычислить массовый
запрос $Q$, то есть ответить на некоторый поставленный вопрос для каждого
запроса из $Q$. Иногда такие задачи решаются в два этапа: предобработка 
(pre-processing) и вычисление запросов на некоторой структуре данных,
формирующейся на этапе предобработки и облегчающей поиск, что позволяет
сократить суммарное время по сравнению с последовательным решением
исходной задачи для каждого запроса.

Логично предположить, что такая структура данных должны быть
подобна хешу (hash) \cite{AHU} или дереву (tree) \cite{QT, SQT, FANN}. В работе \cite{NGRID} была предложена
такая структура данных -- многоуровневая сеть (n-grid). Если потребовать,
чтобы с каждой ячейкой сети ассоциировались только ближайшие к этой
ячейке отрезки, то задача сводится к перебору небольшого числа отрезков.

В данной работе будет описан новый подход к заполнению таких структур --
построение нижних огибающих функций расстояний до отрезков. Также будет описана
структура данных, основанная на заполнении квадродерева (quadtree) этим методом,
с доказательством того, что, при логарифмическом ($O(\log n)$) ограничении высоты дерева,
математическое ожидание числа перебираемых отрезков будет константой, и сравнением ее
с другими существующими реализациями.  
\end{comment}

\FloatBarrier

%-*-coding: utf-8-*-
\chapter{Алгоритм построения маршрутов согласно стратегии
``Параллельное галсирование''}
\section{Алгоритм построения маршрута при
 фиксированном распределении}

\def\dprule{ \rule[-2ex]{0pt}{4ex} }

Для построения маршрута в случае сохранения частицами их положений будет использован метод
динамического программирования. Далее будут описаны состояния алгоритма, его переходы и
вспомогательные значения посчитанные на матрице распределения.

Прежде всего введем сетку на прямоугольнике на котором рассматривается распределение.
Пусть размер сетки будет $H \times W$, размеры ячеек будут одинаковыми, но не обязаны
быть квадратными или выровненными по пикселям текстуры. В частности мы будем стремиться
к очень высокому разрешению по строчкам для более точного определения расстояния между
соседними галсами и нам будет достаточно небольшого разрешения по столбцам. Например 
если размеры текстуры $T_H \times T_W$, а размеры прямоугольника в мире $R_H \times R_W$,
то мы хотим иметь размеры сетки $H = T_H$ и $W \approx \frac {R_w} {1000}$.

\subsection{Состояния алгоритма}
Значением динамического программирования $dp(state)$ для определенного состояния будет
суммарный вес собранных частиц к моменту времени определяемому состоянием. На самом деле
храниться будет весь суммарный весь за исключением покрытого лишь передним полукругом
текущего положения. 

Состоянием динамического программирования является кортеж $(cntHor, row, col, move, notCleared)$.
\begin{itemize}
\item $(row, col)$ --- строка и столбец ячейки в которой закончен маршрут к текущему моменту времени
соответственно.
\item $cntHor$ --- количество горизонтальных перемещений (между столбцами). Если обозначить
за $time_W$ --- время перемещения между двумя соседними ячейками по горизонтали, а за $time_H$ ---
по вертикали, то текущее время можно посчитать как $curTime = time_H \cdot row + time_w \cdot cntHor$.
Здесь использованы предположения, что средство поиска никогда не возвращаемся назад по строчками
(исходя из выбранной стратегии поиска), всегда двигаемся с максимальной скоростью и в начальный
момент времени находится в нулевой строке.
\item $move$ --- тип текущего хода (который завершится в этом состоянии). Принимает значение 
из множества $\{L, R, LU, RU\}$. $L/R$ --- означает, что мы галсируем в текущей строчке влево или
вправо соответственно (галсировать  в обе стороны в одной строчке нельзя). 
$LU/RU$ --- означает, что мы поднимаемся по строчкам, причем в последней строчке в которой мы
галсировали мы двигались влево или вправо соответственно. Уточнение в какую сторону мы двигались
последний раз необходимо для более точного учета собранных нами частиц во время подъема по строчкам.
\item $notCleared$ --- количество пропущенных строк без галсирования. Главное предположение,
позволяющее значительно сократить количество состояний, состоит в том, что для понимания
какие из частиц еще не были собраны в текущей полосе галсирования,
нам достаточно знать когда был предыдущий галс или другими словами сколько строк мы пропустили без
галсирования. Зная какие из частиц не собраны мы сможем рассчитать сколько частиц мы соберем
в текущий момент прохождения маршрута. Данный параметр принимает $N$ значений. $0$ --- означает,
что мы галсировали прямо в предыдущей строчке, $N-1$ --- последний раз мы галсировали $N$ строк
назад либо еще дальше. $N$ выбирается таким образом, чтобы галсирование $N$ строк назад
не оказывало значительного влияния на текущее.
\end{itemize}

\subsection{Вспомогательные матрицы с частичными суммами весов}
Oбозначим радиус зоны видимости средства поиска за $r$. Обозначим функции переводящую
из системы координат построенной сетки в мировую систему координат за $w_x(col), w_y(row)$.

Предположим, что вес частиц в каждом пикселе распределен равномерно. Тогда с помощью
сумм на префиксе, построенных на текстуре за время $O(T_W \cdot T_H)$, можно за $O(1)$
отвечать на запросы вида сумма на прямоугольнике $[x_l ; x_r] \times [y_l ; y_r]$.
При вычислении суммы использутся линейная интерполяция на пикселях частично попавших
в прямоугольник запроса.

\drawfigurex{dpzones}{Типы зон при прохождении маршрута}{dpzones}{0.5\textwidth}

Для подсчета веса частиц, собранных при прохождении маршрута, маршрут будет разделен на
части разного типа (рис. \ref{dpzones}). Как видно из картинки некоторые части могут
быть частично учтены ранее, поэтому важно знать значение $notCleared$ --- сколько строк
было пропущено без галсирования. Таким образом все предпосчитанные матрицы будут возвращать
значения с учетом $notCleared$.

Для примера рассмотрен переход между двумя галсами, содеражащий части всех возможных типов.
В примере ширина ячейки в два раза большее ее высоты. Примеры ячеек сетки динамики 
изображены красными прямоугольниками. Красная точка в цетре 
ячейки сетки обозначает положения средства поиска при нахождении в этом состоянии динамики.
Для упрощения пусть точка с координатами $(row, col)$ совпадает с центром соответствующей ячейки.
Тогда область определения $w_x \in [-0.5; M-0.5]$, а $w_y \in [-0.5; N-0.5]$.
Желтым отмечен маршрут. Разные типы частей помечены различными цветами. Черная сетка на
фоне может интерпретироваться как сетка пикселей.

Рассмотрим вертикальные части синего цвета. Значение матрицы $v[row][col][notCleared]$ ---
будет содержать сумму в прямоугольнике
$[w_x(col-1), w_x(col)] \times [w_y(row)-r, w_y(row)+r]$. Без 
учета частиц собранных ниже прямой $w_y(row-1-notCleared) + r$.

Розовый и оранжевый тип отличаются лишь положением относительно маршрута, справа или слева
соответственно. Матрица для оранжевого 
$hl[row][col][notCleared]$ --- содержит сумму в
$[w_x(col)-r, w_x(col)] \times [w_y(row-1), w_y(row)]$. Матрица для розового
$hr[row][col][notCleared]$ --- содержит $[w_x(col), w_x(col)+r] \times [w_y(row-1), w_y(row)]$.

Обратим внимание на область, покрытую одновременно оражевым и синим цветом в верхей части картинки.
До тех пор пока мы не повернули налево для прохождения нового галса --- эта область будет
учтена как оранжевого типа. После поворота она будет переучтена как область синего.
Для исключения первого ошибочно посчитанного раза необходимо предпосчитать
матрицу $ol[row][col][notCleared]$ --- область $[w_x(col)-r, w_x(col)] \times [w_y(row)-r, w_y(row)]$
и матрицу $or[row][col][notCleared]$ --- область $[w_x(col),w_x(col)+r]\times [w_y(row)-r, w_y(row)]$.

Последним типом являются четверти круга (зеленый цвет), которые должны быть учтены при поворотах.
Суммарный вес под ними будет хранить матрица $cs[row][col][quarter][notCleared]$.
$quarter$ --- обозначает четверть и будет принимать значения $Q_{RU}, Q_{LU}, Q_{LD}, Q_{RD}$
соответсвенно для четвертей в порядке их стандартной нумерации.
\FloatBarrier
\subsection{Переходы между состояниями}
Переходы из состонния динамики \[state=(cntHor, row, col, curMove, notCleared)\] будут
описаны в таблице \ref{table:dp} следующим образом. Текущий ход
$curMove$ будет зафиксирован в первом столбце, следущий выбранный во втором.
$newState$ --- состояние в которое мы перейдем, выбрав такой ход, указано
в четвертом столбце. Все величины, которые нужно добавить при переходе
к величине $dp(state)$ перед релаксацией значения $dp(newState)$ указаны
в третьем столбце. Если обозначить эти величина за $a_i, i \in 1..k$, то более
формально $dp(newState) = min(dp(newState), dp(state) + \sum_{i=1}^{k} a_i)$.
\begin{table}[ht]
  \centering
\begin{tabular}{|l|l|l|l|}
  \hline
  Текущий & Следующий & Собрано на текущем ходу & Новое состояние  \\
  ход & ход & & \\
\hline 
\dprule $L$&$L$&$v[row][col][notCleared]$&$dp[cntHor+1][row][col-1][L][notCleared]$\\
\hline 
\dprule $L$&$LU$&$v[row][col][notCleared]$&$dp[cntHor][row+1][col][LU][0]$\\
\dprule  && $cs[row][col][LDC]$ & \\
\hline 
\dprule $R$&$R$&$v[row][col][notCleared]$&$dp[cntHor+1][row][col+1][R][notCleared]$\\
\hline 
\dprule $R$&$RU$&$v[row][col][notCleared]$&$dp[cntHor][row+1][col][RU][0]$\\
\dprule  && $cs[row][col][RDC]$ & \\
\hline 
\dprule $LU$&$LU$&$v[row][col][0]$&$dp[cntHor][row+1][col][LU][notCleared+1]$\\
\dprule && $hr[row][col]$ & \\
\hline 
\dprule $LU$&$L$&$v[row][col][0]$&$dp[cntHor+1][row][col-1][L][notCleared]$\\
\dprule && $cs[row][col][RUC]$ & \\
\hline 
\dprule $LU$&$R$&$v[row][col][0]$&$dp[cntHor+1][row][col+1][R][notCleared]$\\
\dprule  && $cs[row][col][LUC]$ & \\
\hline 
\dprule $RU$&$RU$&$v[row][col][0]$&$dp[cntHor][row+1][col][RU][notCleared+1]$\\
\dprule && $hl[row][col]$ & \\
\hline 
\dprule $RU$&$L$&$v[row][col][0]$&$dp[cntHor+1][row][col-1][L][notCleared]$\\
\dprule && $cs[row][col][RUC]$ & \\
\hline 
\dprule $RU$&$R$&$v[row][col][0]$&$dp[cntHor+1][row][col+1][R][notCleared]$\\
\dprule && $cs[row][col][LUC]$ & \\
\hline 
\end{tabular}
\captionsetup{justification=centering}
\caption{Переходы из состояния $(cntHor,row,col,curMove,notCleared)$}
\label{table:dp}
\end{table}
\FloatBarrier
\subsection{Оценка времени работы}

\section{Корректировка маршрута}
\FloatBarrier

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

%-*-coding: utf-8-*-
\chapter{Алгоритм построения маршрутов согласно стратегии
``Параллельное галсирование''}
\section{Алгоритм построения маршрута при
 фиксированном распределении}

\def\dprule{ \rule[-2ex]{0pt}{4ex} }

Для построения маршрута в случае сохранения частицами их положений будет использован метод
динамического программирования. Далее будут описаны состояния алгоритма, его переходы и
вспомогательные значения посчитанные на матрице распределения.

Прежде всего введем сетку на прямоугольнике на котором рассматривается распределение.
Пусть размер сетки будет $H \times W$, размеры ячеек будут одинаковыми, но не обязаны
быть квадратными или выровненными по пикселям текстуры. В частности мы будем стремиться
к очень высокому разрешению по строчкам для более точного определения расстояния между
соседними галсами и нам будет достаточно небольшого разрешения по столбцам. Например 
если размеры текстуры $T_H \times T_W$, а размеры прямоугольника в мире $R_H \times R_W$,
то мы хотим иметь размеры сетки $H = T_H$ и $W \approx \frac {R_w} {1000}$.

\subsection{Состояния алгоритма}
Значением динамического программирования $dp(state)$ для определенного состояния будет
суммарный вес собранных частиц к моменту времени определяемому состоянием. На самом деле
храниться будет весь суммарный весь за исключением покрытого лишь передним полукругом
текущего положения. 

Состоянием динамического программирования является кортеж $(cntHor, row, col, move, notCleared)$.
\begin{itemize}
\item $(row, col)$ --- строка и столбец ячейки в которой закончен маршрут к текущему моменту времени
соответственно.
\item $cntHor$ --- количество горизонтальных перемещений (между столбцами). Если обозначить
за $time_W$ --- время перемещения между двумя соседними ячейками по горизонтали, а за $time_H$ ---
по вертикали, то текущее время можно посчитать как $curTime = time_H \cdot row + time_w \cdot cntHor$.
Здесь использованы предположения, что средство поиска никогда не возвращаемся назад по строчками
(исходя из выбранной стратегии поиска), всегда двигаемся с максимальной скоростью и в начальный
момент времени находится в нулевой строке.
\item $move$ --- тип текущего хода (который завершится в этом состоянии). Принимает значение 
из множества $\{L, R, LU, RU\}$. $L/R$ --- означает, что мы галсируем в текущей строчке влево или
вправо соответственно (галсировать  в обе стороны в одной строчке нельзя). 
$LU/RU$ --- означает, что мы поднимаемся по строчкам, причем в последней строчке в которой мы
галсировали мы двигались влево или вправо соответственно. Уточнение в какую сторону мы двигались
последний раз необходимо для более точного учета собранных нами частиц во время подъема по строчкам.
\item $notCleared$ --- количество пропущенных строк без галсирования. Главное предположение,
позволяющее значительно сократить количество состояний, состоит в том, что для понимания
какие из частиц еще не были собраны в текущей полосе галсирования,
нам достаточно знать когда был предыдущий галс или другими словами сколько строк мы пропустили без
галсирования. Зная какие из частиц не собраны мы сможем рассчитать сколько частиц мы соберем
в текущий момент прохождения маршрута. Данный параметр принимает $N$ значений. $0$ --- означает,
что мы галсировали прямо в предыдущей строчке, $N-1$ --- последний раз мы галсировали $N$ строк
назад либо еще дальше. $N$ выбирается таким образом, чтобы галсирование $N$ строк назад
не оказывало значительного влияния на текущее.
\end{itemize}

\subsection{Вспомогательные матрицы с частичными суммами весов}
Oбозначим радиус зоны видимости средства поиска за $r$. Обозначим функции переводящую
из системы координат построенной сетки в мировую систему координат за $w_x(col), w_y(row)$.

Предположим, что вес частиц в каждом пикселе распределен равномерно. Тогда с помощью
сумм на префиксе, построенных на текстуре за время $O(T_W \cdot T_H)$, можно за $O(1)$
отвечать на запросы вида сумма на прямоугольнике $[x_l ; x_r] \times [y_l ; y_r]$.
При вычислении суммы использутся линейная интерполяция на пикселях частично попавших
в прямоугольник запроса.

\drawfigurex{dpzones}{Типы зон при прохождении маршрута}{dpzones}{0.5\textwidth}

Для подсчета веса частиц, собранных при прохождении маршрута, маршрут будет разделен на
части разного типа (рис. \ref{dpzones}). Как видно из картинки некоторые части могут
быть частично учтены ранее, поэтому важно знать значение $notCleared$ --- сколько строк
было пропущено без галсирования. Таким образом все предпосчитанные матрицы будут возвращать
значения с учетом $notCleared$.

Для примера рассмотрен переход между двумя галсами, содеражащий части всех возможных типов.
В примере ширина ячейки в два раза большее ее высоты. Примеры ячеек сетки динамики 
изображены красными прямоугольниками. Красная точка в правом среднем положении от
ячейки сетки обозначает положения средства поиска при нахождении в этом состоянии динамики.
Точка с координатами $(row, col)$ находится в левом нижем углу, соответствующей ей ячейки.
Желтым отмечен маршрут. Разные типы частей помечены различными цветами. Черная сетка на
фоне может интерпретироваться как сетка пикселей.

Рассмотрим вертикальные части синего цвета. Значение матрицы $v[row][col][notCleared]$ ---
будет содержать сумму в прямоугольнике
$[w_x(col), w_x(col+1)] \times [w_y(row+0.5)-r, w_y(row+0.5)+r]$.

\FloatBarrier
\subsection{Переходы между состояниями}
\subsection{Оценка времени работы}
\begin{table}[ht]
  \centering
\begin{tabular}{|l|l|l|l|}
  \hline
  Текущий & Следующий & Собрано на текущем ходу & Новое состояние  \\
  ход & ход & & \\
\hline 
\dprule $L$&$L$&$v[row][col][notCleared]$&$dp[cntHor+1][row][col-1][L][notCleared]$\\
\hline 
\dprule $L$&$LU$&$v[row][col][notCleared]$&$dp[cntHor][row+1][col][LU][0]$\\
\dprule  && $cs[row][col][LDC]$ & \\
\hline 
\dprule $R$&$R$&$v[row][col][notCleared]$&$dp[cntHor+1][row][col+1][R][notCleared]$\\
\hline 
\dprule $R$&$RU$&$v[row][col][notCleared]$&$dp[cntHor][row+1][col][RU][0]$\\
\dprule  && $cs[row][col][RDC]$ & \\
\hline 
\dprule $LU$&$LU$&$v[row][col][0]$&$dp[cntHor][row+1][col][LU][notCleared+1]$\\
\dprule && $hr[row][col]$ & \\
\hline 
\dprule $LU$&$L$&$v[row][col][0]$&$dp[cntHor+1][row][col-1][L][notCleared]$\\
\dprule && $cs[row][col][RUC]$ & \\
\hline 
\dprule $LU$&$R$&$v[row][col][0]$&$dp[cntHor+1][row][col+1][R][notCleared]$\\
\dprule  && $cs[row][col][LUC]$ & \\
\hline 
\dprule $RU$&$RU$&$v[row][col][0]$&$dp[cntHor][row+1][col][RU][notCleared+1]$\\
\dprule && $hl[row][col]$ & \\
\hline 
\dprule $RU$&$L$&$v[row][col][0]$&$dp[cntHor+1][row][col-1][L][notCleared]$\\
\dprule && $cs[row][col][RUC]$ & \\
\hline 
\dprule $RU$&$R$&$v[row][col][0]$&$dp[cntHor+1][row][col+1][R][notCleared]$\\
\dprule && $cs[row][col][LUC]$ & \\
\hline 
\end{tabular}
\captionsetup{justification=centering}
\caption{Переходы из состояния $dp[cntHor][row][col][curMove][notCleared]$}
\label{table:dp}
\end{table}
\FloatBarrier

\section{Корректировка маршрута}
\FloatBarrier

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
